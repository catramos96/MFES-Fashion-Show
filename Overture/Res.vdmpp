class Res
types
	public static TimeType = <Year> | <Month> | <Day> | <Hour> | <Minutes>;
	public static DatePosition = <Before> | <Same> | <After>;
	public String = seq of (char);
	public Date :: year : nat
								 month: nat1
								 day: nat1
								 hours: nat
								 minutes: nat
								 inv mk_Date(y,m,d,h,mn) == m <= 12 and d <= DaysOfMonth(m,y) and h < 24 and mn < 60; 
								 
functions
	/*
	DATE
	*/

	--Method that returns true if the dates overlap and false otherwise
	public static datesOverlap: Date * Date * Date * Date -> bool
	datesOverlap(startDate1, endDate1, startDate2, endDate2) ==
	(
		let o1 = getDatePosition(startDate1,startDate2), --StartDate1 vs StartDate2
		o2 = getDatePosition(startDate1,endDate2),		--StartDate1 vs EndDate2
		o3 = getDatePosition(endDate1,startDate2), 	--EndDate1 vs StartDate2
		o4 = getDatePosition(endDate1,endDate2)		--EndDate1 vs EndDate2	
		in (
		if(((o1 = <Before> or o1 = <Same>) and (o3 = <Same> or o3 = <Before>)) or
			((o2 = <Same> or o2 = <After>) and (o4 = <Same> or o4 = <After>)))
			then false
		else
			true
		)
	);
	
	 	--Method that returns the first date position regarding the second (in the parameters)
	public static getDatePosition: Date * Date -> DatePosition
 	getDatePosition(d1, d2) == getDatePositionAux(d1,d2,<Year>);
	 
	private static getDatePositionAux: Date * Date * TimeType -> DatePosition
 	getDatePositionAux(d1, d2, maxLevel) == (
 	
		cases maxLevel:
			<Year> -> analyseLevel(d1,d2,maxLevel,d1.year,d2.year,<Month>),
			<Month> -> analyseLevel(d1,d2,maxLevel,d1.month,d2.month,<Day>),
			<Day> -> analyseLevel(d1,d2,maxLevel,d1.day,d2.day,<Hour>),
			<Hour> -> analyseLevel(d1,d2,maxLevel,d1.hours,d2.hours,<Minutes>),
			<Minutes> -> analyseLevel(d1,d2,maxLevel,d1.minutes,d2.minutes,<Minutes>)
			end		
	);
	
	private static analyseLevel: Date * Date * TimeType * nat * nat * TimeType -> DatePosition
	analyseLevel(d1,d2,level,tmp1,tmp2,next) ==
	if(tmp1 = tmp2)
		then (
			if(level <> <Minutes>)
				then getDatePositionAux(d1,d2,next)
			else
				<Same>
		)
		else if(tmp1 > tmp2)
		then <After>
		else
		<Before>;	

	--Method that returns the days of the month
	private static DaysOfMonth: nat1 * nat1 +> nat1
	DaysOfMonth(m, y) == 
	(cases m:
			1,3,5,7,8,10,12 -> 31,
			4,5,9,11 -> 30,
			2 -> (if(y mod 4 = 0 and y mod 100 <> 0 or y mod 400 = 0) then 29	--Leap Year
						else 28)
		end);
end Res