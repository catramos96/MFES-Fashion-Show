class Person
	
instance variables
	public name : seq of char;
	public id : nat1;
	public tickets : set of (Ticket);
  public speaks : set of (Presentation);
  public designed : set of (Cloth);
  public jobs: set of Event;
  public attendance : inmap FashionShow to (set of (Event));
  
  inv len name > 0;
  inv forall t in set tickets & t.owner.id = id;	--INV: All tickets addressed to the person
  inv forall s in set speaks & (																											--INV: each presentation (speaks)
  		exists x in set dom attendance & s in set x.events and 													--INV are being attended
  		(exists t in set tickets & t.show = x and t.type = <Guest> or t.type = <VIP>));	--INV: has ticket of type guest to the show
  inv forall c in set designed & c.designer.id = id;	--INV: All clothes designed are marked as designed by the person
  inv forall s in set dom attendance & exists t in set tickets & t.show = s;	--INV: Attendances only in events belonging to a show with a ticket
  
 operations
 
 --Constructor
 public Person: seq of char * nat ==> Person
 Person(name_,id_) == (
 	name := name_; 
 	id := id_; 
 	tickets := {};
 	speaks := {};
 	designed := {};
 	jobs := {};
 	attendance := {|->};
 	return self)
 	pre len name_ > 0;
 	
 	
	 	--Buy Ticket
	 public buyTicket: FashionShow * Ticket`TicketType ==> ()
	 buyTicket(show,type) == (
	 	if(show.canSellTicket(type))
	 		then (
	 		addTicket(show.sellTicket(self,type))
	 		)
	 )
	 pre not exists t in set tickets & t.show = show;	--PRE: Can only have 1 ticket per show
	 
	 --Add Ticket
	 public addTicket: Ticket ==> ()
	 addTicket(t) == (
	 	tickets := tickets union {t};
	 	attendance := attendance ++ {t.show |-> {}}
	 	)
	 pre t.owner = self and t not in set tickets							--PRE: Person is owner of ticket
	 post (t in set tickets and t.show in set dom attendance);--POS: New Ticket in tickets and show in attendance schedule (per show)
	 
	 --Remove Ticket
	 public removeTicket: Ticket ==> ()
	 removeTicket(t) == (
	 	tickets := tickets \ {t}
	 )
	 pre t in set tickets				--PRE: Has ticket
	 post t not in set tickets;	--POS: Ticket was removed
 	
 	--------------------
 	----- ATTENDEE -----
 	--------------------
 	
 	--Add guest speaking
 	public addSpeaking: Presentation ==> ()
 	addSpeaking(presentation) == (
 		speaks := speaks union {presentation};
 	)
 	pre isWorking(presentation.startTime,presentation.endTime,jobs,speaks)
 	post presentation in set speaks;
 	
 	--Get Next Attendance
 	public getNextAttendance: Utils`Date ==> [Event]
 	getNextAttendance(currentDate) == (
 		dcl event : Event;
 		dcl notNull : bool := false;
 		
 		for all e in set dunion rng attendance do (	--All events attending
 			--If it's after the current date
			if(Utils`getDatePosition(e.startTime,currentDate) = <After>) then(	
				--Has to compare with other already found
				if(notNull) then (
					--Compare
					if(Utils`getDatePosition(e.startTime, event.startTime) = <After>) then
						event := e;
				)
				else (
					event := e;
					notNull := true;
				)
			)
 		);
 		
 		return event
 	);
 	
 	--Get Attendance
 	public getAttendance: FashionShow ==> set of Event
 	getAttendance(show) == (
 		return attendance(show);
 	)
 	pre show in set dom attendance
 	post forall e in set attendance(show) & e in set RESULT;
 	
 	--Get Attendance Notifications
 public getAttendanceNotifications: FashionShow ==> set of Notification
 getAttendanceNotifications(show) == (
 	dcl notifications : set of Notification := {};
 	
 	for all event in set attendance(show) do (
 		notifications := notifications union event.getNotifications(<Attendees>)
 	);
 	
 	return notifications
 )
 pre show in set dom attendance
 post forall n in set RESULT & n.type = <Attendees>;
 
  
 --Attend
 public attend: Event ==> ()
 attend(event) == (
 	dcl show: FashionShow := iota x in set dom attendance & event in set x.events,
 			ticket: Ticket := iota x in set tickets & show = x.show;
 	attendance := attendance ++ {show |-> (attendance(show) union {event})};
 	if(ticket.type = <Normal> or ticket.type = <Guest>) then event.reserveSeat()
 )
 pre exists t in set tickets & event in set t.show.events and 	--PRE: Event belongs to a ticket show
 	event not in set attendance(t.show)														--PRE: Event is not reserved 
 post event in set dunion rng attendance;														--POS: Reservation to event with success
  
 --Cancel Attendment
 public cancelAttendment: Event ==> ()
 cancelAttendment(event) == (
	 	if(event in set dunion rng attendance) then (
		 	dcl show : FashionShow := iota x in set dom attendance & exists e in set attendance(x) & e = event;
		 	attendance := attendance ++ {show |-> (attendance(show) \ {event})};
		 	event.freeSeat();
	 );
	 if(is_Presentation(event)) then
	 	cancelPresentation(event);
 )
 post event not in set dunion rng attendance;	--POS: Event not in the attendance
 
 --Cancel Presentation
 public cancelPresentation: Presentation ==> ()
 cancelPresentation(presentation) == (
 	speaks := speaks \ {presentation};
 	if(self in set presentation.speakers) then
 		presentation.removeSpeaker(self);
 )
 pre presentation in set speaks				--PRE: Is Speaker at the presentation
 post presentation not in set speaks;	--POS: Is no longer the speaker
 
 ------------------
 ----- Worker -----
 ------------------
 
 --Get Job Notifications
 public getJobNotifications: Notification`Type ==> set of Notification
 getJobNotifications(type) == (
 	dcl notifications : set of Notification := {};
 	
 	if(type = <Workers>) then (
	 	for all event in set jobs do(
	 		notifications := notifications union event.getNotifications(<Workers>)
	 	);
 	)
 	else (
 		for all event in set dunion rng attendance do (
 			notifications := notifications union event.getNotifications(<Attendees>);
 		);
 	);
 	return notifications
 )
 post forall n in set RESULT & n.type = type;
  
 --Add Job
 public addJob: Event ==> ()
 addJob(e) == (jobs := jobs union {e})
 pre isWorking(e.startTime,e.endTime,jobs,speaks) = false	--PRE: Job does not overlap another
 post e in set jobs;																			--POS: New Job was added to workSchedule
 
 --RemoveJob
 public removeJob: Event ==> ()
 removeJob(j) ==(jobs := jobs \ {j})
 pre j in set jobs					--PRE: Person has job
 post j not in set jobs;		--POS: Person dismissed from job
 
 --------------------
 ----- DESIGNER -----
 --------------------
 
 --AddCloth
 public addCloth: Cloth ==> ()
 addCloth(cloth) == (designed := designed union {cloth})
 pre cloth.designer.id = id and cloth not in set designed
 post cloth in set designed;
 
 --Is Designer
 	public isDesigner: () ==> bool
 	isDesigner() ==  (
 		if(card designed = 0) 
 			then return false
 		else
 			return true);
 			
 	functions 
 	
 	--Has Ticket to show
	 public hasTicketToShow : FashionShow * set of Ticket -> bool
	 hasTicketToShow(show,tickets) == (exists t in set tickets & t.show = show);
	 	
 	--Is Working (Function)
 	public static isWorking: Utils`Date * Utils`Date * set of Event * set of Presentation-> bool
  isWorking(startD,endD,jobs,speaks) == (
 	(exists event in set jobs & Utils`datesOverlap(event.startTime,event.endTime,startD,endD)) or			-- Has work ?
 	(exists speak in set speaks & Utils`datesOverlap(speak.startTime,speak.endTime,startD,endD))			-- Has presentation ?
 	)
 	pre Utils`getDatePosition(startD,endD) = <Before>;	--PRE: start time < end time
end Person