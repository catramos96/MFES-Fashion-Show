class FashionShow
 ---------------------------------------------------------------------------
 instance variables
 	public theme : Utils`String; 		
  public startTime : Utils`Date;
  public endTime : Utils`Date;
  public space : Space;
  
  public events : set of (Event);
	public nEntries : map Ticket`TicketType to nat1; 								--Max capacity for each ticket type
	public ticketsSold : map Ticket`TicketType to set of (Ticket);	--Sold
  
  inv othersINV(theme,startTime,endTime);
 	inv ticketsINV(ticketsSold,nEntries,theme);
  inv eventsINV(events,space,startTime,endTime);
  
 ---------------------------------------------------------------------------
 operations
 	--Constructor
 	public FashionShow: Utils`String * Space * Utils`Date * Utils`Date * nat * nat * nat ==> FashionShow
  FashionShow(theme_, space_, startTime_, endTime_, maxVip_, maxNormal_, maxGuest_) == (
  theme := theme_; 
  space := space_; 
  startTime := startTime_; 
  endTime := endTime_; 
  nEntries := {<VIP> |-> maxVip_, <Normal> |-> maxNormal_, <Guest> |-> maxGuest_};
  ticketsSold := {<VIP> |-> {}, <Normal> |-> {}, <Guest> |-> {}};
  events := {};
  space.addReservation(self);
  return self )
  pre othersINV(theme_,startTime_,endTime_)
  post self in set space.reservations and theme = theme_
  and startTime = startTime_ and endTime = endTime_ and space = space_;
  
  --Add Event
  public addEvent: Event ==> ()
  addEvent(e) == (events := events union {e})
  pre Utils`datesContainsDates(startTime,endTime,e.startTime,e.endTime) and
  		e.stage in set space.stages and not exists e2 in set events & Event`eventsOverlap(e,e2)
  post e in set events;														--POS: New event in events
  
  --CancelEvent
  public cancelEvent: Utils`String ==> ()
  cancelEvent(name) == (
  	dcl event: Event := iota x in set events & x.name = name;
  	for all w in set event.workers do ( event.dismissWorker(w) );
  	for all t in set dunion rng ticketsSold do (t.owner.cancelAttendment(event));
  	events := events \ {event};
  )
  pre exists e in set events & e.name = name					--Exist event
  post (not exists e in set events & e.name = name);	--Event was removed
    
  --SellTicket
  public sellTicket: Person * Ticket`TicketType ==> Ticket
  sellTicket(attendee, type) == (
  	dcl t :Ticket := new Ticket(type,attendee, self);
  	ticketsSold := ticketsSold ++ {type |-> (ticketsSold(type) union {t})};
  	return t
  )
  pre nEntries(type) > card ticketsSold(type) and								--PRE: Has entries for ticket type
  		type <> <Guest>																						--PRE: Canno't buy guest tickets
  post (card ticketsSold~(type) + 1 = card ticketsSold(type)); 	--POS: Ticket was sold
  
  --InviteGuest
  public inviteGuest: Person * [Presentation] ==> ()
  inviteGuest(guest,presentation) == (
  	dcl t : Ticket := new Ticket(<Guest>,guest,self);
  	ticketsSold := ticketsSold ++ { <Guest> |-> ticketsSold(<Guest>) union {t}};
  	
  	if(presentation <> nil) then 
  		presentation.addSpeaker(guest);
  		
  	guest.addTicket(t);								--Is given a ticket
  	
  	if(presentation <> nil) then(
	  	guest.addSpeaking(presentation);	--Is speaking
	  	guest.attend(presentation);				--Is attending
  	)
  )
  pre Person`isWorking(presentation.startTime,presentation.endTime,guest.jobs,guest.speaks) = false	--PRE: guest has free time
  post exists t in set ticketsSold(<Guest>) & t.owner = guest;	--POS: guest was added
  
  --Can sell ticket
  public canSellTicket: Ticket`TicketType ==> bool
  canSellTicket(type) == (
  	return nEntries(type) > card ticketsSold(type)
  );
  
  --Get Attending Designers
  public getAttendingDesigners: () ==> set of Person
  getAttendingDesigners() == (
  	dcl designers : set of Person := {};
  	for all t in set dunion rng ticketsSold do(
  		if(card t.owner.designed > 0) then designers := designers union {t.owner}
  	);
  	
  	return designers;
  )
  post forall p in set RESULT & card p.designed > 0 and 	--POS: designers have clothes designed
  	exists t in set p.tickets & t.show = self;						--POS: are attending this show
  	
  --Get Attending Designers to Event
  public getAttendingDesignersToEvent: Event ==> set of Person
  getAttendingDesignersToEvent(event) == (
	  dcl designers : set of Person := {};
	  	for all t in set dunion rng ticketsSold do(
	  		if(card t.owner.designed > 0 and event in set t.owner.attendance(self)) 
	  		then designers := designers union {t.owner}
	  	);
  	
  	return designers;
  )
   post forall p in set RESULT & card p.designed > 0 and 	--POS: designers have clothes designed
  	exists t in set p.tickets & t.show = self and					--POS: have ticket to the show
  	event in set p.attendance(self);											--POS: attending the event
  	
  --Get Participating Designers
  public getParticipatingDesigners: () ==> set of Person
  getParticipatingDesigners() == (
  	dcl designers : set of Person := {};
  	
  	for all e in set events do(
  		if(is_Runway(e)) then designers := designers union e.getDesigners()
  	);
  	
  	return designers
  )
  post forall p in set RESULT & card p.designed > 0 and	--POS: designers have clothes designed
  	exists event in set p.jobs & event in set events and--POS: have a job in an event that is a runway
  	is_Runway(event);
  	
  --Get Workers
  public getWorkers: () ==> set of Person
  getWorkers() == (
  	dcl workers : set of Person := {};
  	for all e in set events do (
  		workers := workers union e.workers;
  	);
  	return workers;
  )
  post forall w in set RESULT & 						--POST Worker has a job in an event of the show
  exists e in set events & e in set w.jobs;
  
  
  --SETS--
  
  
  --Set number of entries
  public setNEntries: Ticket`TicketType * nat ==> ()
  setNEntries(type,n) == (nEntries := nEntries ++ {type|->n})
  pre n >= card ticketsSold(type)																--PRE: Can only set to a number equal or above the number sold
  post nEntries(type) = n;																			--POS: Number of tickets was set
  
  --Set Theme
  public setTheme: Utils`String ==> ()
  setTheme(theme_) == (theme := theme_)
  pre len theme_ > 0		--PRE: Theme must be > 0
  post theme = theme_;	--POS: Theme was changes
  
  --Set Space
  public setSpace: Space ==> ()
  setSpace(newSpace) == (
  	dcl old : Space := space;
	  newSpace.addReservation(self);
	  space := newSpace;
	  old.removeReservation(self)
  )
  post space = newSpace;
  
  --Set Time
  public setTime: Utils`Date * Utils`Date ==> ()
  setTime(start_,end_) == (atomic(startTime := start_; endTime := end_))
  pre Utils`getDatePosition(start_,end_) = <Before> and 								--PRE: Start date must be before the end date
  not exists e in set events & 																					--PRE: All events must be inside the new time limits
  Utils`datesContainsDates(start_,end_,e.startTime,e.endTime) = false
  post startTime = start_ and endTime = end_;
  
  ---------------------------------------------------------------------------
  functions
  
  --INVARIANTS--
  
  --Others
  public static othersINV: Utils`String * Utils`Date * Utils`Date -> bool
  othersINV(theme,startTime,endTime) == (
  	 Utils`getDatePosition(startTime,endTime) = <Before> and 	--INV: start time < end time
  		len theme > 0																						--INV: theme must have a name
  );
  
  --Tickets
  public static ticketsINV: map Ticket`TicketType to (set of (Ticket)) * map Ticket`TicketType to nat1 * Utils`String -> bool
  ticketsINV(tickets,entries,theme) == (
  	(forall t in set dunion rng tickets & t.show.theme=theme) and										--INV: tickets sold must be regarding the show						
    (not exists t1,t2 in set dunion rng tickets & t1<>t2 and t1.owner=t2.owner)and 	--INV: tickets can only be sold once to the same person
    (forall type in set dom entries & card tickets(type) <= entries(type))					--INV: nº of tickets sold must be equal or less than the nº entries
  );
  
  --Events
  public static eventsINV: set of Event * Space * Utils`Date * Utils`Date -> bool
  eventsINV(events,space,startTime,endTime) == (
  	(forall e in set events & e.stage in set space.stages and 									--INV: events in stages belonging to the show		
  		Utils`datesContainsDates(startTime,endTime,e.startTime,e.endTime)) and		--INV: events between the show dates							
    (not exists e1,e2 in set events & e1 <> e2 and Event`eventsOverlap(e1,e2))	--INV: events don't overlap							
  );
  
  --OTHERS--
  
  --Two shows are overlaping if the dates overlap in the same space
  public static showsOverlap: FashionShow * FashionShow -> bool
  showsOverlap(s1,s2) == (Space`equal(s1.space,s2.space) and 
  Utils`datesOverlap(s1.startTime,s1.endTime,s2.startTime,s2.endTime)
  );
  
  --Two shows are equal if they have the same theme name
  public static equals: FashionShow * FashionShow -> bool
  equals(s1,s2) == s1.theme = s2.theme;
 
end FashionShow
