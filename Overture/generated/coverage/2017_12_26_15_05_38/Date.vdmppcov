class Date
types
	public static TimeType = <Year> | <Month> | <Day> | <Hour> | <Minutes>;
	public static DatePosition = <Before> | <Same> | <After>;
 
instance variables
 public year: nat1;
 public month: nat1;
 public day: nat1;
 public hour: nat;
 public minutes: nat;
 public allDay: bool; -- Hours and minutes are irrelevant
 
 inv month <= 12 and day <= DaysOfMonth(month,year) and hour < 24 and minutes < 60;
 
operations
	--Constructor with hours
	public Date: nat1 * nat1 * nat1 * nat * nat ==> Date
	Date(year_, month_, day_, hour_, minutes_) ==
	(year := year_; month := month_; day := day_; hour := hour_; minutes := minutes_; allDay:= false; return self);
	
	--Constructor just the date
	public Date: nat1 * nat1 * nat1 ==> Date
	Date(year_, month_, day_) ==
	(year := year_; month := month_; day := day_; hour := 0; minutes := 0; allDay:= true; return self);
	 
	 	--Method that returns the first date position regarding the second (in the parameters)
	public static getDatePosition: Date * Date ==> DatePosition
 	getDatePosition(d1, d2) ==
 	return getDatePositionAux(d1,d2,<Year>);
	 
	private static getDatePositionAux: Date * Date * TimeType ==> DatePosition
 	getDatePositionAux(d1, d2, maxLevel) ==
	(
		dcl t1: nat, t2: nat, next: TimeType;
		cases maxLevel:
			<Year> -> atomic(t1 := d1.year; t2 := d2.year; next := <Month>),
			<Month> -> atomic(t1 := d1.month; t2 := d2.month; next := <Day>),
			<Day> -> atomic(t1 := d1.day; t2 := d2.day; next := <Hour>),
			<Hour> -> atomic(t1 := d1.hour; t2 := d2.hour; next := <Minutes>),
			<Minutes> -> atomic(t1 := d1.minutes; t2 := d2.minutes)
		end;
		
		if(t1 = t2)
		then (
			if(maxLevel <> <Minutes>)
				then return getDatePositionAux(d1,d2,next)
			else
				return <Same>
		)
		else if(t1 > t2)
		then return <After>;
		
		return <Before>;
	);
	
	--Method that returns true if the dates overlap and false otherwise
	public static datesOverlap: Date * Date * Date * Date ==> bool
	datesOverlap(startDate1, endDate1, startDate2, endDate2) ==
	(
		dcl o1: DatePosition, o2: DatePosition, o3: DatePosition, o4: DatePosition;
		
		o1 := getDatePosition(startDate1,startDate2);		--StartDate1 vs StartDate2
		o2 := getDatePosition(startDate1,endDate2);			--StartDate1 vs EndDate2
		o3 := getDatePosition(endDate1,startDate2);			--EndDate1 vs StartDate2
		o4 := getDatePosition(endDate1,endDate2);				--EndDate1 vs EndDate2
		
		if(((o1 = <Before> or o1 = <Same>) and (o3 = <Same> or o3 = <Before>)) or
			((o2 = <Same> or o2 = <After>) and (o4 = <Same> or o4 = <After>)))
			then return false;
			
		return true;
	);
		
functions
	--Method that returns the days of the month
	private static DaysOfMonth: nat1 * nat1 +> nat1
	DaysOfMonth(m, y) == 
	(cases m:
			1,3,5,7,8,10,12 -> 31,
			4,5,9,11 -> 30,
			2 -> (if(y mod 4 = 0 and y mod 100 <> 0 or y mod 400 = 0) then 29	--Leap Year
						else 28)
		end);
	
traces
-- TODO Define Combinatorial Test Traces here
end Date