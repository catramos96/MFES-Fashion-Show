class Event
	instance variables
	  public startTime : Utils`Date;
	  public endTime : Utils`Date;
	  public name : Utils`String;
	  public stage: Stage;
	  public workers : set of (Person);
	  public news: set of (Notification);
	  
	  inv Utils`getDatePosition(startTime,endTime) = <Before>;
	  inv forall w in set workers & exists e in set w.jobs & 
	  	e.name = name and e.stage = stage and e.startTime = startTime and e.endTime = endTime;
	  inv not exists n1,n2 in set news & n1<> n2 and Notification`equals(n1,n2);
	  
	operations
	 --Constructor
	 	public Event: Utils`String * Stage * Utils`Date * Utils`Date ==> Event
		Event(name_, stage_, startDate_, endDate_) == (
			atomic(
			name := name_; 
			stage := stage_; 
			startTime := startDate_; 
			endTime := endDate_; 
			workers := {};
			news := {});
			return self;
		);
		
		--Get  Notifications
		public getNotifications: Notification`Type ==> set of (Notification)
		getNotifications(type) == (
			dcl notifications : set of Notification := {};
			
			for all n in set news do(
				if(n.type = type) then notifications := notifications union {n}
			);
			
			return notifications
		)
		post forall n in set RESULT & n.type = type;	--POS: Notifications are of a specific type
		
		--Add Notification
		public addNotification: Notification ==> ()
		addNotification(n) == (
			news := news union {n};
		)
		pre not exists n2 in set news & Notification`equals(n,n2)
		post n in set news;
		
		--Remove Notification
		public removeNotification: Notification ==> ()
		removeNotification(n) == (news := news \ {n})
		pre n in set news
		post n not in set news; 
		
		--Add Worker
		public addWorker: Person ==> ()
		addWorker(w) == (
		w.addJob(self);
		workers:= workers union {w}
		)
		pre w not in set workers			--PRE: Worker not in workers already
		post w in set workers;				--POS: New worker was added
		
		--Dismiss Worker
		public dismissWorker: Person ==> ()
		dismissWorker(worker) == (
			workers := workers \ {worker};
			worker.removeJob(self);
		)
		pre worker in set workers				--PRE: Has worker
		post worker not in set workers;	--POS: Worker was dismissed
				
		--Update Workers
		public updateWorkers: set of Person ==> ()
		updateWorkers(workers_) == (
			for all w in set workers_ do w.addJob(self);
			workers := workers_;
		);
		
		--Reserve Seat
		public reserveSeat: () ==> ()
		reserveSeat() == (stage.reserved := stage.reserved + 1)
		pre stage.reserved < stage.seats						--PRE: must have free seats
		post stage.reserved = stage~.reserved + 1;	--POS: reserved seats was inc
		
		--Free Seat
		public freeSeat: () ==> ()
		freeSeat() == (stage.reserved := stage.reserved - 1)
		pre stage.reserved > 0											--PRE: must have reserved seats
		post stage.reserved + 1 = stage~.reserved;	--POS: reserved seats was dec
	
	functions
		--Overlap
		public static eventsOverlap: Event * Event -> bool
		eventsOverlap(e1,e2) == (
			if(e1.stage = e2.stage)
				then Utils`datesOverlap(e1.startTime,e1.endTime,e2.startTime,e2.endTime)
			else e1.name = e2.name
		);

end Event
